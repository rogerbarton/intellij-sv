{
    parserClass="ch.rbarton.intellijsv.core.parser.SvParser"
    parserUtilClass="ch.rbarton.intellijsv.core.parser.SvParserUtil"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    // Use extension methods instead so we can use kotlin, see https://github.com/JetBrains/Grammar-Kit/issues/70
     psiImplUtilClass="ch.rbarton.intellijsv.core.psi.mixin.SvPsiImplUtil"

    psiClassPrefix="Sv"
    psiImplClassSuffix="Impl"
    psiPackage="ch.rbarton.intellijsv.core.psi"
    psiImplPackage="ch.rbarton.intellijsv.core.psi.ext"

    elementTypeHolderClass="ch.rbarton.intellijsv.core.psi.SvTypes"
    elementTypeClass="ch.rbarton.intellijsv.core.psi.SvElementType"
    tokenTypeClass="ch.rbarton.intellijsv.core.psi.SvTokenType"

    tokens = [
        LBRACE      = '{'
        RBRACE      = '}'
        LBRACK      = '['
        RBRACK      = ']'
        LPARENSTAR  = '(*'
        LPAREN      = '('
        RPARENSTAR  = '*)'
        RPAREN      = ')'

        COLONCOLON  = '::'
        COLON       = ':'
        SEMICOLON   = ';'
        COMMA       = ','

        SHA         = '#'
        SHASHA      = '##'
        DOT         = '.'
        UNDERSCORE  = '_'

        // Operators
        EQEQQS      = '==?'
        EQEQEQ      = '==='
        EQEQ        = '=='
        EQ          = '='
        EXCLEQQS    = '!=?'
        EXCLEQEQ    = '!=='
        EXCLEQ      = '!='
        EXCL        = '!'

        PLUSEQ      = '+='
        PLUSPLUS    = '++'
        PLUS        = '+'
        MINUSEQ     = '-='
        MINUSGT     = '->'
        MINUSMINUS  = '--'
        MINUS       = '-'
        MULMUL      = '**'
        MULEQ       = '*='
        MUL         = '*'
        DIVEQ       = '/='
        DIV         = '/'
        PCTEQ       = '%='
        PCT         = '%'

        TILDAND     = '~&'
        TILDOR      = '~|'
        TILDHAT     = '~^'
        TILD        = '~'
        HATTILD     = '^~'
        HATEQ         = '^='
        HAT         = '^'

        GTEQ        = '>='
        GTGTGTEQ    = '>>>='
        GTGTEQ      = '>>='
        GTGTGT      = '>>>'
        GTGT        = '>>'
        GT          = '>'
        LTEQ        = '<='
        LTMINUSLT   = '<->'
        LTLTLTEQ    = '<<<='
        LTLTEQ      = '<<='
        LTLTLT      = '<<<'
        LTLT        = '<<'
        LT          = '<'

        OREQ        = '|='
        OROR        = '||'
        OR_         = '|'
        ANDEQ       = '&='
        ANDANDAND   = '&&&'
        ANDAND      = '&&'
        AND_        = '&'

        // Literals
        TIME_LITERAL    = "regexp:\d[_\d]*(s|ms|us|ns|ps|fs)"
        BINARY_NUMBER   = "regexp:\d[_\d]*'[sS]?[bB][01XxZz?][_01XxZz?]*"
        OCTAL_NUMBER    = "regexp:\d[_\d]*'[sS]?[oO][0-7XxZz?][_0-7XxZz?]*"
        HEX_NUMBER      = "regexp:\d[_\d]*'[sS]?[hH][0-9ABCDEFXxZz?][_0-9ABCDEFXxZz?]*"
        UNSIGNED_NUMBER = 'regexp:\d[_\d]*'
        SPECIAL_NUMBER  = "regexp:'0|'1|'|x|X|z|Z"

        WHITE_SPACE     = 'regexp:[\s\r\n]+'
        IDENTIFIER      = 'regexp:[a-zA-Z_][a-zA-Z0-9_$]*'
        LINE_COMMENT    = 'regexp://.*'
        DOC_COMMENT     = 'regexp:/\*\*(.|\n)*?\*/'
        BLOCK_COMMENT   = 'regexp:/\*(.|\n)*?\*/'

        STRING_LITERAL  = "regexp:\"[^\"]*?\"" // Doesn't handle escapes
    ]

    generateTokenAccessors=true

    // Reduce size of PSI tree for recursive parts
    extends(".*Stmt|SeqBlock") = Statement
    extends(".*Expr") = Expression
    extends(".*ExprConst") = ExpressionConst

    // Performance for expressions, simplier error messages
    consumeTokenMethod("((?!.*_with_recover).*_recover|Primary)") = "consumeTokenFast"
}

SvFile ::= [ (TimeunitsDeclaration ';' )* ] ModuleDeclaration *

// Generic Recovers

private Semicolon_recover ::= !';'
private CSV_recover ::= !(';' | ',' | ')' | '*)')   // Must include comma

// Meta Rules

private meta CSV ::= <<XSV <<item>> ','>>
private meta XSV ::= <<item>> ( <<sep>> <<item>> )* <<sep>>?

// Trivial Rules

IdentifierRule ::= IDENTIFIER
Label ::= IDENTIFIER
UnsignedNumberRule ::= UNSIGNED_NUMBER
TimeLiteralRule ::= TIME_LITERAL

// Timeunits

TimeunitsDeclaration ::=

      timeunit TimeLiteralRule [ '/' TimeLiteralRule ]
    | timeprecision TimeLiteralRule {
    pin(".*") = 1
    recoverWhile = Semicolon_recover
}

// Module

ModuleDeclaration ::=

    AttributeInstance *
    module IDENTIFIER ModuleHeader ';'
    ModuleItem *
    endmodule [ ':' Label ] {
    pin = 3
    implements = "ch.rbarton.intellijsv.core.psi.ext.SvNamedIdentifierOwner"
    mixin = "ch.rbarton.intellijsv.core.psi.mixin.SvModuleDeclarationMixin"
    methods = [
        endmoduleLabel = "Label"
    ]
    }

ModuleHeader ::=

    [ '#' '(' [ <<CSV ParameterDeclaration>> ] ')' ]
    [     '(' [ <<CSV PortDeclaration>> ] ')' ] {
    pin(".*") = 1
    recoverWhile = Semicolon_recover
}

// Parameter Declarations

ParameterDeclaration ::= ParameterType Type IDENTIFIER UnpackedDimension * [ '=' Expression ] {
    pin = 1
    recoverWhile = CSV_recover
    methods = [ defaultValue = "Expression" ]
}

ParameterType ::= parameter | localparam

// Port Declarations

PortDeclaration ::=

    AttributeInstance *  PortDirection Type IDENTIFIER [ '=' ExpressionConst ] {
    pin = 2
    methods = [ defaultValue = "ExpressionConst" ]
    recoverWhile = CSV_recover
    }

PortDirection ::= input | output | inout | ref

// Module Item

ModuleItem ::=

      ParameterDeclaration ';'
    | TypeDeclaration ';'
    | ContinuousAssign ';'
    | AlwaysConstruct
    | InitialConstruct
    | FinalConstruct
    | ModuleInstantiation ';'
    | NetDeclaration ';'  // After ModuleInstantiation
    | GenerateRegion
    | TimeunitsDeclaration ';'
    | ModuleDeclaration

NetDeclaration ::= Type <<CSV IdentifierWithDefault>> !'('{
    pin = 1
    recoverWhile = Semicolon_recover
}

IdentifierWithDefault ::= IDENTIFIER [ '=' Expression ] {
}

ContinuousAssign ::= assign <<CSV ContinuousAssignItem>> {
    pin = 1
    recoverWhile = Semicolon_recover
}

ContinuousAssignItem ::= NetLvalue AssignOperator Expression {
    pin = 2
    recoverWhile = CSV_recover
}

NetLvalue ::= HierarchicalIdentifier UnpackedDimension *

// Procedural blocks

InitialConstruct ::= initial Statement {
    pin = 1
}

AlwaysConstruct ::= AlwaysKeyword Statement {
    pin = 1
}

FinalConstruct ::= final Statement {
    pin = 1
}

//noinspection BnfSuspiciousToken
AlwaysKeyword ::= always_comb | always_ff | always_latch | always

Statement ::=

    [ IDENTIFIER ':' ] AttributeInstance *
    (
          SeqBlock
        | AssignmentStmt ';'
        | ConditionalStmt
        | TimingControlStmt
    )

SeqBlock ::=

    begin [ ':' IdentifierRule ]
    BlockItem *
    Statement *
    end [ ':' IdentifierRule ] {
    pin = 1
    }

BlockItem ::=

    AttributeInstance * (
      TypeDeclaration
    | ParameterDeclaration
    ) ';'

AssignmentStmt ::= NetLvalue AssignOperator Expression {
    pin = 2
    recoverWhile = Semicolon_recover
}

ConditionalStmt ::=

    [ UniquePriority ]
    if '(' Expression ')'
        Statement
    ( else if '(' Expression ')'
        Statement ) *
    [ else
        Statement ] {
    pin = 2
    }

UniquePriority ::= unique | unique0 | priority

TimingControlStmt ::= ( EventControl | DelayControl | DelayCycle ) ( ';' | Statement )

EventControl ::=

    '@' (
      '(' ( EventExpression | '*' )')'
    | '*'
    | HierarchicalIdentifier
    ) {
    pin = 1
}

DelayControl ::= '#' ( DelayLiteral | '(' Expression ')' ) {
    pin = 1
}

DelayLiteral ::= UNSIGNED_NUMBER | TIME_LITERAL | IDENTIFIER | "1step"

DelayCycle ::= '##' ( UNSIGNED_NUMBER | IDENTIFIER | '(' Expression ')' ) {
    pin = 1
}

EventExpression ::=

      ParenEventExpression
    | BinaryEventExpression
    | AtomicEventExpression

AtomicEventExpression ::= [ EdgeIdentifier ] Expression [ iff Expression ] {
    extends = EventExpression
}

BinaryEventExpression ::= EventExpression ( or | ',' ) EventExpression {
    extends = EventExpression
}

ParenEventExpression ::= '(' EventExpression ')' {
    extends = EventExpression
}


EdgeIdentifier ::= posedge | negedge | edge

// Module Instantiation

ModuleInstantiation ::= IdentifierRule [ '#' PortValueAssignment ] IdentifierRule [ PortValueAssignment ] {
    methods = [
        moduleIdentifier = '/IdentifierRule[0]'
        instanceIdentifier = '/IdentifierRule[1]'
    ]
    implements = [ "ch.rbarton.intellijsv.core.psi.ext.SvReferenceElement" ]
    mixin = "ch.rbarton.intellijsv.core.psi.mixin.SvModuleInstantiationMixin"
}

PortValueAssignment ::= '(' [ <<CSV Expression>> | <<CSV NamedParameterAssignment>> ] ')' {
    pin = 1
}

NamedParameterAssignment ::= '.' IDENTIFIER '(' [ Expression ] ')' {
    pin = 1
    recoverWhile = NamedParameterAssignment_recover
}

private NamedParameterAssignment_recover ::= !(',' | ')')

GenerateRegion ::= generate GenerateItem endgenerate

GenerateItem ::= TODO

// Types

Type ::=

    ( BuiltinType | IDENTIFIER ) [ Signing ] [ UnpackedDimension ]
    | IntegerAtomType [ Signing ]
    | NonIntegerType
    | EnumDeclaration
    | StructUnionDeclaration
    | string

TypeDeclaration ::= typedef (
      [ enum | struct | union | class ] IDENTIFIER
    | Type IDENTIFIER VariableDimension *
)   {
    recoverWhile = Semicolon_recover
    methods = [ class_kw = "class" ]
}

EnumDeclaration ::= enum [ EnumBaseType ] '{' <<CSV EnumMember>> '}' PackedDimension *

EnumBaseType ::=

      IntegerAtomType [ Signing ]
    | IntegerVectorType [ Signing ] [ PackedDimension ]
    | IDENTIFIER [ PackedDimension ]

EnumMember ::= IDENTIFIER [ '[' UnsignedNumberRule [ ':' UnsignedNumberRule ] ] [ '=' ExpressionConst ]

StructUnionDeclaration ::= ( struct | union ) [ packed [ Signing ] ] '{' StructUnionMember + '}' PackedDimension *

StructUnionMember ::= AttributeInstance * Type <<CSV IdentifierWithDefault>> ';'

// Dimensions

UnpackedDimension ::= '[' Expression ':' Expression ']' {
//    pin = 1
}

private PackedDimension ::= UnpackedDimension

UnsizedDimension ::= '[' ']'

VariableDimension ::=

      UnsizedDimension
    | UnpackedDimension

BitSelectConst ::= '[' ExpressionConst ']'

// Built-in Types and Related Keywords

Signing ::= signed | unsigned

BuiltinType ::= logic | int | wire | reg

IntegerAtomType ::= byte | shortint | int | longint | integer | time

IntegerVectorType ::= bit | logic | reg

NonIntegerType ::= shortreal | real | realtime

private IntegerType ::= IntegerVectorType | IntegerAtomType

SimpleType ::= IntegerType | NonIntegerType | IDENTIFIER

// Expressions

Expression ::=

      ParenExpr
    | UnaryExpr
    | BinaryExpr
    | IncDecExpr
    | TernaryExpr
    | Primary

ExpressionConst ::=

      UnaryExprConst
    | BinaryExprConst
    | TernaryExprConst
    | PrimaryConst

Primary ::=

      Literal
    | HierarchicalIdentifier
    | ConcatenationPrimary
    | MultiConcatenationPrimary
    | Cast {
        extends = Expression
    }

PrimaryConst ::=

      Literal
    | ConcatenationPrimaryConst
    | MultiConcatenationPrimaryConst {
        extends = ExpressionConst
    }

ParenExpr ::= '(' Expression ')'

UnaryExpr ::= UnaryOperator AttributeInstance* Primary

UnaryExprConst ::= UnaryOperator AttributeInstance* PrimaryConst

BinaryExpr ::= Expression BinaryOperator AttributeInstance * Expression

BinaryExprConst ::= ExpressionConst BinaryOperator AttributeInstance * ExpressionConst

TernaryExpr ::= Expression '?' AttributeInstance * Expression ':' Expression

TernaryExprConst ::= ExpressionConst '?' AttributeInstance * ExpressionConst ':' ExpressionConst

IncDecExpr ::=
      IncDecOperator AttributeInstance * NetLvalue
    | NetLvalue AttributeInstance * IncDecOperator

Cast ::= CastingType "'" '(' Expression ')'

CastingType ::= Signing | string | const | PrimaryConst | SimpleType

ConcatenationPrimary ::= '{' <<CSV Expression>> '}'

ConcatenationPrimaryConst ::= '{' <<CSV ExpressionConst>> '}'

MultiConcatenationPrimary ::= '{'  '}'

MultiConcatenationPrimaryConst ::= '{' ExpressionConst ConcatenationPrimaryConst '}'

HierarchicalIdentifier ::= [ "$root" '.' ] ( IDENTIFIER BitSelectConst * '.' ) * IDENTIFIER

// Operators

UnaryOperator ::=

    '+' | '-' | '!' | '~' | '&' | '~&' | '|' | '~|' | '^' | '~^' | '^~'

BinaryOperator ::=

      '+'  | '-'  | '*'   | '/'   | '%'
    | '==' | '!=' | '===' | '!==' | '==?' | '!=?'
    | '&&' | '||' | '**'
    | '<'  | '<=' | '>'   | '>='
    | '&'  | '|'  | '^'   | '^~'  | '~^'
    | '>>' | '<<' | '>>>' | '<<<'
    | '->' | '<->'
    | '&&&' // predicate

IncDecOperator ::= '++' | '--'

AssignOperator ::= '=' | '<='

AssignmentOperator ::=

    "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" |
    "|=" | "^=" | "<<=" | ">>=" | "<<<=" | ">>>="

// Literals

Literal ::= TIME_LITERAL | NumberLiteral | SPECIAL_NUMBER | STRING_LITERAL

NumberLiteral ::= BINARY_NUMBER | OCTAL_NUMBER | HEX_NUMBER | UNSIGNED_NUMBER

// Attributes

AttributeInstance ::= '(*' <<CSV IdentifierWithDefault>> '*)' {
    pin = 1
//    recoverWhile = AttributeInstance_recover
}

private AttributeInstance_recover ::= !'*)'
