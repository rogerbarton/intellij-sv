{
    parserClass="ch.rbarton.intellijsv.core.parser.SvParser"
    parserUtilClass="ch.rbarton.intellijsv.core.parser.SvParserUtil"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    // Use extension methods instead so we can use kotlin, see https://github.com/JetBrains/Grammar-Kit/issues/70
     psiImplUtilClass="ch.rbarton.intellijsv.core.psi.impl.SvPsiImplUtil"

    psiClassPrefix="Sv"
    psiImplClassSuffix="Impl"
    psiPackage="ch.rbarton.intellijsv.core.psi"
    psiImplPackage="ch.rbarton.intellijsv.core.psi.impl"

    elementTypeHolderClass="ch.rbarton.intellijsv.core.psi.SvTypes"
    elementTypeClass="ch.rbarton.intellijsv.core.psi.SvElementType"
    tokenTypeClass="ch.rbarton.intellijsv.core.psi.SvTokenType"

    tokens = [
        LPARENSTAR  =  '(*'
        RPARENSTAR  =  '*)'

        LBRACE      =  '{'
        RBRACE      =  '}'
        LBRACK      =  '['
        RBRACK      =  ']'
        LPAREN      =  '('
        RPAREN      =  ')'

        COLON       =  ':'
        COLONCOLON  =  '::'
        SEMICOLON   =  ';'
        COMMA       =  ','

        EQ          =  '='
        DIV         =  '/'

        SHA         =  '#'
        DOT         =  '.'
        UNDERSCORE  =  '_'

        GTGT      = ">>"
        GTEQ      = ">="
        LTLT      = "<<"
        LTEQ      = "<="
        OROR      = "||"
        ANDAND    = "&&"
        ANDANDAND = "&&&"

        // Literals
        TIME_LITERAL    = "regexp:\d[_\d]*(s|ms|us|ns|ps|fs)"
        BINARY_NUMBER   = "regexp:\d[_\d]*'[sS]?[bB][01XxZz?][_01XxZz?]*"
        OCTAL_NUMBER    = "regexp:\d[_\d]*'[sS]?[oO][0-7XxZz?][_0-7XxZz?]*"
        HEX_NUMBER      = "regexp:\d[_\d]*'[sS]?[hH][0-9ABCDEFXxZz?][_0-9ABCDEFXxZz?]*"
        UNSIGNED_NUMBER = 'regexp:\d[_\d]*'
        SPECIAL_NUMBER  = "regexp:'0|'1|'|x|X|z|Z"

        WHITE_SPACE     = 'regexp:[\s\r\n]+'
        IDENTIFIER      = 'regexp:[a-zA-Z_][a-zA-Z0-9_$]*'
        LINE_COMMENT    = 'regexp://.*'
        DOC_COMMENT     = 'regexp:/\*\*(.|\n)*?\*/'
        BLOCK_COMMENT   = 'regexp:/\*(.|\n)*?\*/'

        STRING_LITERAL  = "regexp:\"[^\"]*?\"" // Doesn't handle escapes
    ]

    generateTokenAccessors=true

    consumeTokenMethod("((?!.*_with_recover).*_recover)") = "consumeTokenFast"
}

SvFile ::= [ (TimeunitsDeclaration ';' )* ] ModuleDeclaration *

// Generic Rules

private Statement_recover ::= !';'
private CSV_recover ::= !(';' | ',' | ')' | '*)')   // Must include comma

private meta CSV ::= <<XSV <<item>> ','>>
private meta XSV ::= <<item>> ( <<sep>> <<item>> )* <<sep>>?


// Trivial Rules
IdentifierRule ::= IDENTIFIER
UnsignedNumberRule ::= UNSIGNED_NUMBER
TimeLiteralRule ::= TIME_LITERAL

// Timeunits

TimeunitsDeclaration ::=

      timeunit TimeLiteralRule [ '/' TimeLiteralRule ]
    | timeprecision TimeLiteralRule {
    pin(".*") = 1
    recoverWhile = Statement_recover
}

// Module

ModuleDeclaration ::=

    AttributeInstance *
    module IdentifierRule ModuleHeader ';'
    ModuleItem *
    endmodule [ ':' IdentifierRule ] {
    pin = 2
    mixin = "ch.rbarton.intellijsv.core.psi.ext.SvNamedElementImpl"
    implements = "ch.rbarton.intellijsv.core.psi.ext.SvNamedElement"
    methods = [getName setName getNameIdentifier getPresentation
        identifier = "IdentifierRule[0]"
        identifierPostfix = "IdentifierRule[1]"
    ]
    }

ModuleHeader ::=

    [ '#' '(' [ <<CSV ParameterDeclaration>> ] ')' ]
    [     '(' [ <<CSV PortDeclaration>> ] ')' ] {
    recoverWhile = Statement_recover
}

// Parameter Declarations

ParameterDeclaration ::= ParameterType Type IDENTIFIER UnpackedDimension * [ '=' Expression ] {
    pin = 1
    methods = [ defaultValue = "Expression" ]
}

ParameterType ::= parameter | localparam

// Port Declarations

PortDeclaration ::=

    AttributeInstance *  PortDirection Type IDENTIFIER [ '=' ConstantExpression ] {
    pin = 2
    methods = [ defaultValue = "ConstantExpression" ]
    }

PortDirection ::= input | output | inout | ref

// Module Item

ModuleItem ::=

      NetDeclaration ';'
    | ParameterDeclaration ';'
    | TypeDeclaration ';'
    | ContinuousAssign ';'
    | AlwaysConstruct
    | InitialConstruct
    | FinalConstruct
    | ModuleInstantiation ';'
    | GenerateRegion
    | TimeunitsDeclaration ';'
    | ModuleDeclaration

NetDeclaration ::= Type <<CSV IdentifierWithDefault>> {
    pin = 1
}

IdentifierWithDefault ::= IDENTIFIER [ '=' Expression ] {
    recoverWhile = CSV_recover
}

ContinuousAssign ::= assign <<CSV Assignment>> {
    pin = 1
    recoverWhile = Statement_recover
}

Assignment ::= NetLvalue AssignOperator Expression {
    pin = 2
    recoverWhile = CSV_recover
}

NetLvalue ::= IDENTIFIER UnpackedDimension *

AssignOperator ::= '=' | '<='

// Procedural blocks

InitialConstruct ::= initial Statement {
    pin = 1
}

AlwaysConstruct ::= AlwaysKeyword Statement {
    pin = 1
}

FinalConstruct ::= final Statement {
    pin = 1
}

//noinspection BnfSuspiciousToken
AlwaysKeyword ::= always_comb | always_ff | always_latch | always

Statement ::=

    [ IDENTIFIER ':' ]
    AttributeInstance *
    StatementItem

private StatementItem ::=

      SeqBlock
    | Assignment ';'
    | ConditionalStmt

SeqBlock ::=

    begin [ ':' IdentifierRule ]
    BlockItem *
    Statement *
    end [ ':' IdentifierRule ] {
    pin = 1
    }

BlockItem ::=

    AttributeInstance * (
      TypeDeclaration
    | ParameterDeclaration
    ) ';'

ConditionalStmt ::=

    [ UniquePriority ]
    if '(' Predicate ')'
        Statement
    ( else if '(' Predicate ')'
        Statement ) *
    [ else
        Statement ]{
    pin = 2
    }

UniquePriority ::= unique | unique0 | priority

Predicate ::= <<XSV Expression '&&&'>>

// Module Instantiation

ModuleInstantiation ::= IdentifierRule [ '#' PortValueAssignment ] IdentifierRule [ PortValueAssignment ] {
    methods = [
        moduleIdentifier = '/IdentifierRule[0]'
        instanceIdentifier = '/IdentifierRule[1]'
    ]
}

PortValueAssignment ::= '(' [ <<CSV Expression>> | <<CSV NamedParameterAssignment>> ] ')' {
    pin = 2
}

NamedParameterAssignment ::= '.' IDENTIFIER '(' [ Expression ] ')'

GenerateRegion ::= generate GenerateItem endgenerate

GenerateItem ::= TODO

// Types

Type ::=

    ( BuiltinType | IDENTIFIER ) [ Signing ] [ UnpackedDimension ]
    | IntegerAtomType [ Signing ]
    | NonIntegerType
    | EnumDeclaration
    | StructUnionDeclaration
    | string

TypeDeclaration ::= typedef (
      [ enum | struct | union | class ] IDENTIFIER
    | Type IDENTIFIER VariableDimension *
)

EnumDeclaration ::= enum [ EnumBaseType ] '{' <<CSV EnumMember>> '}' PackedDimension *

EnumBaseType ::=

      IntegerAtomType [ Signing ]
    | IntegerVectorType [ Signing ] [ PackedDimension ]
    | IDENTIFIER [ PackedDimension ]

EnumMember ::= IDENTIFIER [ '[' UnsignedNumberRule [ ':' UnsignedNumberRule ] ] [ '=' ConstantExpression ]

StructUnionDeclaration ::= ( struct | union ) [ packed [ Signing ] ] '{' StructUnionMember + '}' PackedDimension *

StructUnionMember ::= AttributeInstance * Type <<CSV IdentifierWithDefault>> ';'

// Dimensions

UnpackedDimension ::= '[' Expression ':' Expression ']'

private PackedDimension ::= UnpackedDimension

UnsizedDimension ::= '[' ']'

VariableDimension ::=

      UnsizedDimension
    | UnpackedDimension

// Built-in Types and Related Keywords

Signing ::= signed | unsigned

BuiltinType ::= logic | int | wire | reg

IntegerAtomType ::= byte | shortint | int | longint | integer | time

IntegerVectorType ::= bit | logic | reg

NonIntegerType ::= shortreal | real | realtime

// Expressions

Expression ::= IDENTIFIER | ConstantExpression

ConstantExpression ::= Literal


// Literals

Literal ::= TIME_LITERAL | NumberLiteral | SPECIAL_NUMBER | STRING_LITERAL

NumberLiteral ::= BINARY_NUMBER | OCTAL_NUMBER | HEX_NUMBER | UNSIGNED_NUMBER

// Attributes

AttributeInstance ::= '(*' <<CSV IdentifierWithDefault>> '*)' {
    pin = 1
//    recoverWhile = AttributeInstance_recover
}

private AttributeInstance_recover ::= !'*)'
