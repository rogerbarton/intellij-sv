{
    parserClass="ch.rbarton.intellijsv.core.parser.SvParser"
    parserUtilClass="ch.rbarton.intellijsv.core.parser.SvParserUtil"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    // Use extension methods instead so we can use kotlin, see https://github.com/JetBrains/Grammar-Kit/issues/70
     psiImplUtilClass="ch.rbarton.intellijsv.core.psi.impl.SvPsiImplUtil"

    psiClassPrefix="Sv"
    psiImplClassSuffix="Impl"
    psiPackage="ch.rbarton.intellijsv.core.psi"
    psiImplPackage="ch.rbarton.intellijsv.core.psi.impl"

    elementTypeHolderClass="ch.rbarton.intellijsv.core.psi.SvTypes"
    elementTypeClass="ch.rbarton.intellijsv.core.psi.SvElementType"
    tokenTypeClass="ch.rbarton.intellijsv.core.psi.SvTokenType"

    tokens = [
        LBRACE      =  '{'
        RBRACE      =  '}'
        LBRACK      =  '['
        RBRACK      =  ']'
        LPAREN      =  '('
        RPAREN      =  ')'

        COLON       =  ':'
        COLONCOLON  =  '::'
        SEMICOLON   =  ';'
        COMMA       =  ','

        EQ          =  '='
        DIV         =  '/'

        SHA         =  '#'
        DOT         =  '.'
        UNDERSCORE  =  '_'

        GTGT      = ">>"
        GTEQ      = ">="
        LTLT      = "<<"
        LTEQ      = "<="
        OROR      = "||"
        ANDAND    = "&&"

        WHITE_SPACE     = 'regexp:[\s\r\n]+'
        IDENTIFIER      = 'regexp:[a-zA-Z_][a-zA-Z0-9_$]*'
        LINE_COMMENT    = 'regexp://.*'
        DOC_COMMENT     = 'regexp:/\*\*(.|\n)*?\*/'
        BLOCK_COMMENT   = 'regexp:/\*(.|\n)*?\*/'

        // Literals
        UNSIGNED_NUMBER = 'regexp:\d[_\d]*'
        BINARY_NUMBER   = "regexp:\d[_\d]*'[sS]?[bB][01XxZz?][_01XxZz?]*"
        OCTAL_NUMBER    = "regexp:\d[_\d]*'[sS]?[oO][0-7XxZz?][_0-7XxZz?]*"
        HEX_NUMBER      = "regexp:\d[_\d]*'[sS]?[hH][0-9ABCDEFXxZz?][_0-9ABCDEFXxZz?]*"
    ]

//    generateTokenAccessors=true

    consumeTokenMethod("((?!.*_with_recover).*_recover)") = "consumeTokenFast"
}

SvFile ::= [ (TimeunitsDeclaration ';' )* ] ModuleDeclaration *

// Generic Rules

private Statement_recover ::= !';'
private StatementCsv_recover ::= !(';' | ',')

private meta CSV ::= <<param>> ( ',' <<param>> )* ','?


// Trivial Rules
IdentifierRule ::= IDENTIFIER
UnsignedNumberRule ::= UNSIGNED_NUMBER


// Timeunits

TimeunitsDeclaration ::=

      timeunit TimeLiteral [ '/' TimeLiteral ]
    | timeprecision TimeLiteral {
    pin(".*") = 1
    recoverWhile = Statement_recover
}


TimeLiteral ::= UNSIGNED_NUMBER TimeUnit

TimeUnit ::= s | ms | us | ns | ps | fs

// Module

ModuleDeclaration ::=

    module IdentifierRule ModuleHeader ';'
    ModuleItem *
    endmodule [ ':' IdentifierRule ] {
    pin = 2
    mixin = "ch.rbarton.intellijsv.core.psi.ext.SvNamedElementImpl"
    implements = "ch.rbarton.intellijsv.core.psi.ext.SvNamedElement"
    methods = [getName setName getNameIdentifier getPresentation
        identifier = "/IdentifierRule[0]"
        identifierPostfix = "/IdentifierRule[1]"
    ]
    }

ModuleHeader ::=

    [ '#' '(' [ <<CSV ParameterDeclaration>> ] ')' ]
    [     '(' [ <<CSV PortDeclaration>> ] ')' ] {
    recoverWhile = Statement_recover
}

// Parameter Declarations

ParameterDeclaration ::= ParameterType Type IDENTIFIER UnpackedDimension * [ '=' Expression ] {
    methods = [ defaultValue = "ConstantExpression" ]
}

ParameterType ::= parameter | localparam

// Port Declarations

PortDeclaration ::=

    PortDirection Type IDENTIFIER [ '=' ConstantExpression ] {
    methods = [ defaultValue = "ConstantExpression" ]
    }

PortDirection ::= input | output | inout | ref

// Module Item

ModuleItem ::=

      NetDeclaration ';'
    | ParameterDeclaration ';'
    | AssignStmt ';'
    | AlwaysStmt
    | ModuleInstantiation ';'
    | GenerateRegion
    | TimeunitsDeclaration ';'
    | ModuleDeclaration

NetDeclaration ::= Type <<CSV IdentifierWithDefault>>

IdentifierWithDefault ::= IDENTIFIER [ '=' Expression ] {
    recoverWhile = StatementCsv_recover
}

AssignStmt ::= assign <<CSV Assignment>> {
    pin = 1
}

Assignment ::= NetLvalue AssignOperator Expression {
    recoverWhile = StatementCsv_recover
}

NetLvalue ::= IDENTIFIER UnpackedDimension *

AssignOperator ::= '=' | '<='

// Always

AlwaysStmt ::= AlwaysKeyword AlwaysItem {
    pin = 1
}

AlwaysKeyword ::= 'always_comb' | 'always_ff' | 'always_latch' | 'always'

AlwaysItem ::= [ IDENTIFIER ':' ] StatementItem

StatementItem ::=

      Assignment ';'


// Module Instantiation

ModuleInstantiation ::= IdentifierRule [ '#' PortValueAssignment ] IdentifierRule [ PortValueAssignment ] {
    methods = [
        moduleIdentifier = '/IdentifierRule[0]'
        instanceIdentifier = '/IdentifierRule[1]'
    ]
}

PortValueAssignment ::= '(' [ <<CSV Expression>> | <<CSV NamedParameterAssignment>> ] ')' {
    pin = 2
}

NamedParameterAssignment ::= '.' IDENTIFIER '(' [ Expression ] ')'

GenerateRegion ::= generate GenerateItem endgenerate

GenerateItem ::= TODO

// Types

Type ::= (BuiltinType | IDENTIFIER) [ signed | unsigned ] [ UnpackedDimension ]

BuiltinType ::= logic | int | wire | reg

UnpackedDimension ::= '[' Expression ':' Expression ']'

// Expressions

Expression ::= IDENTIFIER | ConstantExpression

ConstantExpression ::= Number

Number ::= BINARY_NUMBER | OCTAL_NUMBER | HEX_NUMBER | UNSIGNED_NUMBER

